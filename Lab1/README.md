# Lab 1 Introduction to C#

* Deadline: 08.09.2022
* The lab has to be manually approved by the teaching assistants during lab hour.
  * The student is expected to explain the code during the manually approval.
  * All code has to be submitted before the deadline, but can be approved on the first lab after the deadline.
  * It is possible to get the code approved before the deadline.

## Overview

Please go through the [signup process for QuickFeed](https://github.com/dat240-2022/info/signup.md) before starting the lab.

### Program flow

Under is the general program flow described. 

1. Print output
2. Read string from the console
3. Split string to command and data
4. Parse strings to other value types
5. Create queue implementation
6. Insert element
7. Take out element
8. Implement IEnumerable
9. Error if no more elements can be taken out
10. Priority queue insert and remove

* The queue implementations should be based on a C# array.

### Prerequisite

To complete this lab, you would need:

* A command line program
  * Windows: Preferably powershell (already installed). 
    * A nice shell for powershell is [Windows Terminal](https://www.microsoft.com/nb-no/p/windows-terminal/9n0dx20hk701) (might be installed with windows)
  * Linux: A terminal is already installed.
  * Mac: A terminal is already installed. 
* git
  * Check if git is installed by running git in the command line with the command `git`
  * Basic instructions for installing git can be found [here](./Git.md)
* Dotnet 5 installed. Installation instructions can be found on this link [https://dotnet.microsoft.com/download/dotnet/5.0](https://dotnet.microsoft.com/download/dotnet/5.0).
  * Either install the latest **x64** 5.0.x version for your platform under **Build apps - SDK** → **Installers**.
  * Or use the [dotnet-install scripts](https://dotnet.microsoft.com/download/dotnet/scripts)
    * Install dotnet 5 with the command `.\dotnet-install 5.0`
    * For dotnet install script on windows then you might have to run the command `Set-ExecutionPolicy RemoteSigned` to enable script execution in PowerShell
* Visual Studio Code
  * (It is possible to use other code editors, but we cannot provide help for those).
  * Installation can be found here: [https://code.visualstudio.com/](https://code.visualstudio.com/)
    * As part of the windows VSCode installation it is recommended to check the two `Add "Open with code" action to Windows explorer ...` options
* Recommended VSCode extensions
  * Please clone the assignments repository and open the assignments folder in VSCode.
  * VSCode will then prompt to install the recommended extensions.
  * Install the recommended extensions.
    * If this for some reason should not happen, then it is possible to find the list [here](../.vscode/extensions.json).

After the installation it could be a nice thing to log out and in again or just restart the computer.

### Useful links:

* Important for VSCode debugging https://docs.microsoft.com/en-us/dotnet/core/tutorials/debugging-with-visual-studio-code#set-up-for-terminal-input
* Using C# with Visual Studio Code [here](https://code.visualstudio.com/docs/languages/csharp)
* Learn C# [here](https://dotnet.microsoft.com/learn/csharp)
* Learn http status codes with http cats [here](https://http.cat/), (not useful for lab1)
* We could have a long list here but google is better at lists.

## Description

### Opening the lab in VSCode

To start this lab, please navigate to the Lab1 folder and open it in VSCode. When OmniSharp prompts you for which project to choose please select Lab1.sln. This will be the same for all the labs, choose the .sln file.

There might by a description of the [folder structure](./FolderStructure.md) for Lab1.

### The lab

The lab already contains a C# console application in the Lab1/UiS.Dat240.Lab1 folder and can be started by navigating to the folder in the command line and writer `dotnet run`. You should then be greeted by the ubiquitous `Hello World!` code. The console app was generated by running the command: `dotnet new console`.

The code that greets us in the [program.cs](./UiS.Dat240.Lab1/Program.cs) file is the following:

```csharp
using System;
namespace UiS.Dat240.Lab1
{
    public class Program
    {
        static void Main(string[] args)
        {
           // TODO: Implement
           Console.WriteLine("Hello World!");
        }
    }
}
```

Here is a lot of code to do a simple thing, which is to write the string `Hello World!` to the console window. Currently it is the `Hello World` line that is interesting, which writes the lines to a console window. All you need to know for now is that `static void Main(string[] args)` is a main function which does not return anything (`void`), and expects to get a string array `string[] args` as input. The curly braces `{ }` defines a code body, and the `Main` function is the first thing that is executed in a C# program. The other things just need to be there for now and is mostly about naming things and telling the compiler what we want to use.

Just a heads up, as of the next version of dotnet and C# ([dotnet 6](https://devblogs.microsoft.com/dotnet/announcing-net-6-preview-1/) and [C# 10](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10)), then the starting template is drastically changed. Below is the new starter code which will not work for this lab, but will in November when dotnet 6 is release. (Or if you for some reason installed the dotnet 6 preview)

```csharp
Console.WriteLine("Hello World!");
```
(And no, it is not a mistake. The new Program.cs format removes everything else expect the Console.WriteLine).

### Console input and output

The first thing you can try is to do with the code to get your feet wet are:
* Manipulate the string `"Hello World"`, 
* Add multiple `Console.WriteLine's`, 
* Try the `Console.Write` function instead of, which does not include the new line at the end of the output.

### Command line program

The first part of the lab should be to read an input from the user and handling what the user writes. The [Console.ReadLine](https://docs.microsoft.com/en-us/dotnet/api/system.console.readline?view=net-5.0) function can do this operation. After the input is read then it should be [split](https://docs.microsoft.com/en-us/dotnet/api/system.string.split?view=net-5.0) into command part and data part. The commands which should be implemented can be found in the table below. 

The command reading should read one command after another and only the `exit` command should stop this execution. `CTRL + C` and closing the terminal will also stop the program, and this is expected.

Before we have a real queue implementation it would be nice to test that the command handling is working correctly. This can be accomplished by writing the user input back to the console window. You can try and mimic the following behaviour:

```text
> add Some test value
You wrote: "Some test value"
> rem
You wrote the remove command
> exit
```

### Commands:

| Command name | Description                                                         |
| ------------ | ------------------------------------------------------------------- |
| add {value}  | Adds the `{value}` to the queue                                     |
| rem          | Removes the first value from the queue and prints it to the console |
| size         | prints the number of items in the queue                             |
| exit         | Exits the command tool                                              |

### The test project

Let’s learn a little bit about testing our code in an automatic way. We have already prepared a test project which can run some simple test on the queue implementation. If you navigate to the [UiS.Dat240.Lab1/QueueTests.cs](./UiS.Dat240.Lab1.Tests/QueueTests.cs) file you will see three tests. We are using xunit to simplify testing of the code. 

If you have configured VSCode properly then there should be a codelens (The line between the [Fact] and the public void line which cannot be edited) that says something like `0 references | Run Test | Debug test`. The `Run Test` and `Debug Test` is clickable and either starts the test in run mode or in debug mode. In debug mode break points will be hit and it is possible to inspect the code and figure out what the code is doing step by step. If this line is absent, either try to use [Google](https://www.google.com) or ask for help. A restart of the code editor/computer might also do the trick. 

It is also possible to execute the test via the command line. To do this navigate to the folder with the .csproj file and write `dotnet test`. This will run all the tests found the folder.

The nice thing about these tests, (which are [unit test](https://en.wikipedia.org/wiki/Unit_testing) in this case), is that you can take some of the code and verify that it behaves the way you think without having to start the entire application. If we also start to write the test at the same time, we write the implementation then we are forced to write somewhat testable code. Testable code is maybe a little misleading in this case, since all code can be tested in some way, but a lot of code is very easy to write but hard to test since it has a lot of dependencies.

The easiest to write a new test is to copy one of the tests and make some changes to it. One example is to insert to items in the queue instead of one and see that they come out again in the correct order. Another test could be that there is thrown an exception by the code when the code tries to extract an element from an empty queue.

### Building a queue

The second part of the lab is implementing three different versions of a queue. The three queues are [IStringQueue](./UiS.Dat240.Lab1/Queues/IStringQueue.cs), [IObjectQueue](./UiS.Dat240.Lab1/Queues/IObjectQueue.cs) and finally [IGenericQueue<T>](./UiS.Dat240.Lab1/Queues/IGenericQueue.cs). You should first implement the IStringQueue, since then it would be much easier to implement the last two queues as well. Then the object queue should be implemented and lastly, we are going to implement the GenericQueue. 

The FIFO queue (First in First out) implementations should use a [C# Array](https://docs.microsoft.com/en-us/dotnet/api/system.array?view=net-5.0) as the data storage. C# arrays are fixed size which means the code must handle automatic growth of the array to accommodate more elements. [Dynamic Arrays](https://en.wikipedia.org/wiki/Dynamic_array) and [Circular buffers](https://en.wikipedia.org/wiki/Circular_buffer) can be nice starting points for the queue implementation.

The queue should have the following functionality:

| Functionality | Interface definition        | Description                                                                                                                                                                                                     |
| ------------- | --------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Enqueue(item) | void Enqueue(string value); | Adds a value to the end of the queue                                                                                                                                                                            |
| Dequeue()     | string Dequeue();           | Returns the first element or throws an exception if the queue is empty                                                                                                                                          |
| Length { get; } | int Length { get; }         | Returns the number of elements in the queue as an integer                                                                                                                                                       |
| Grow()        | Not defined in interfaces   | When called it will create a new array of double the size as the old, copy all elements from the old array to the new array in the same order, then it should assign the new array as the working data storage. |

### IStringQueue

When creating the string queue, first create a class called something like `StringQueue` and then implement the interface `IStringQueue` as shown below. In C# we use the `:` to implement interfaces and derive from other (base/super) classes.

```csharp
public class StringQueue : IStringQueue
{
  public int Length { get; }
  public void Enqueue(string value)
  {
    throw new NotImplementedException();
  }
  public string Dequeue()
  {
    throw new NotImplementedException();
  }
}
```

The main difference between the queues are the types used for storage. The first one can only store strings, but it is easier to reason about since string is a concrete implementation. This queue can also be used for the implementation of the command handling of the program.

After the queue is created then navigate to the [TestSubmissions.cs](./UiS.Dat240.Lab1/TestSubmissions.cs) and modify the code so that it returns a new instance of your string queue implementation as shown below. 

```csharp
public static IStringQueue CreateStringQueue()
{
    // TODO: Implement
    throw new NotImplementedException();
}
```

```csharp
public static IStringQueue CreateStringQueue()
{
    return new StringQueue();
}
```

Also remember to commit and push the changes so you know the QuickFeed score and have saved your work to GitHub. It is a good idea to commit and check the code with QuickFeed after each part of the lab.

### IObjectQueue

Since we at this point have already created the string queue then it is much easier to create the object queue. Create a new class and copy the implementation from the string class and change the `string` types to `object` type instead. 

Now we are basically done, but the big benefit now is that we can store anything which can be [cast](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions) into an object, which in C#, is everything. The bad thing about this implementation is that we do not know what we have stored in the queue, since everything looks like objects. We can also store `strings`, `ints` and anything else in the same queue instance, which can be hard to keep track of.

Do the same for the `ObjectQueue` as the `StringQueue` and add it to the [TestSubmissions.cs](./UiS.Dat240.Lab1/TestSubmissions.cs) file. This will be the same for each implementation.

### Clean up

Now we have two queues which is twice the amount of code to maintain! We also previously mentioned that the `ObjectQueue` can store anything, including strings, so why have two? The next part is creating an encapsulation class or wrapper class which implements the `IStringQueue` interface by using the `ObjectQueue` instead of the concrete implementation.

* Change the existing `StringQueue` or create a new class by creating a new `ObjectQueue` field and assigning it an empty `ObjectQueue`. 
* Change the Enqueue, Dequeue and Size to call the `ObjectQueue` implementations instead
* The Grow function can be deleted since that is handle by the `ObjectQueue`

One thing to note is that Enqueue is easy to implement, it is just calling the `ObjectQueue.Enqueue` function, but the Dequeue is harder. In C# all types are automatically (implicit) cast to a less specific type (for instance a base class or an interface). This means that since everything in C# is an object, then the string is implicitly cast to the object type. The other way around is not true since we do not know what the object should be. More information about casting can be found at the following links:
* https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression
* https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions
* https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions

Use the information in the links to cast the object back to a string before returning it from the dequeue function.

### The Generic Queue IGenericQueue&lt;T&gt;

The bad thing about the string implementation is that we must create a new queue implementation for each type we want, and the bad thing about the object queue is that we have no clue what is in the queue. So, the solution for this is making the C# compiler do all the hard work and create all the type specific versions for us. This is called [generics](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics) and is about using a type variable instead of a concrete type. A type variable is much like a parameter where we do not know the value, but in the case of generics, then we do not know the type. We almost always use the type variable `T` or a name with a `T` as a prefix ex. `TInput` to specify a type parameter. Generics is like creating a template for a `class`, `struct`, `record` or `Method`, where we decide when using the code what type it should be. 

For those that finds this concept cool, then it could be nice to read about a new upcoming dotnet feature which makes [Generic Math](https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/) possible, which takes this concept one step further.

Create a new class with a generic parameter `T` and implement the IGenericQueue&lt;T&gt; interface and copy the ObjectQueue code. Replace all object with T and we are done. Now we should do the same with GenericQueue that we did with ObjectQueue and replace the implementation of both the StringQueue and ObjectQueue to use the new implementation. As you would see, then this is much simpler since we just create a `GenericQueue<string>` for the string queue and `GenericQueue<object>` for the object queue, and then we do not need to cast anything!

### Extending the command line

The third part of this lab is extending the command line program with the following functionality:

| Command name              | Description                                                                         |
| ------------------------- | ----------------------------------------------------------------------------------- |
| addpri {priority} {value} | Add a priority item with the given `{priority}` and `{value}` to the priority queue |
| rempri                    | Prints the priority and value of the item with the highest priority in the queue    |
| sizepri                   | returns the size of the priority queue                                              |

You might have guessed it already, but we need to implement a priority queue for this part of the lab. This should also use a C# array as a data storage and how to implement it can be found here:

* https://en.wikipedia.org/wiki/Binary_heap
* https://en.wikipedia.org/wiki/Priority_queue

Also to understand the [IGenericPriorityQueue.cs](./UiS.Dat240.Lab1/Queues/IGenericPriorityQueue.cs) interface, it is probably nice to read a little about tuples:

* https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples

The requirements for the priority queue are that an item with a higher priority should always be dequeued before an item with a lower priority. You do not have to guarantee that two items of the same priority are dequeued in the same order as they are enqueued, meaning that if you only insert items of the same priority, then there is no guarantee that the data structure works as a FIFO queue. 

### IEnumerable

Since we now have some nice data structures, then it would be nice if we could look through them without having to dequeue and re enqueue all the different elements of the queue. It is possible to do that, but it would require a lot of processing. The way we are going to do this is by using the standard C# way of looking through data structures, which is the [foreach](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement) way. As you also can read from the link is that the foreach statement work on a `type` that implements the [IEnumerable](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable?view=net-5.0) or the generic version [IEnumerable<T>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1?view=net-5.0) interfaces. A `type` in this case is any `type` that can implement an interface which are `class`, `struct` or `record` constructs.

The `IEnumerable<T>` should be implemented for the `IGenericQueue<T>` for the tests to pass. There are two ways of creating the enumerable code, where one of them is returning a [IEnumerator<T>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerator-1?view=net-5.0) which navigates through each element one by one, and there is the [yield return](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield). Follow the examples on the links to implement the IEnumerable so the code can be used in a foreach statement. The yield way is probably easier to implement, but yield is just making the compiler implement an IEnumerator for us which is nice.
