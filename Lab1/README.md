# Lab 1 Introduction to C#

* Deadline: 08.09.2022
* The lab has to be manually approved by the teaching assistants during lab hour.
  * The student is expected to explain the code during the manually approval.
  * All code has to be submitted before the deadline, but can be approved on the first lab after the deadline.
  * It is possible to get the code approved before the deadline.

## Overview

Please go through the [signup process for QuickFeed](https://github.com/dat240-2022/info/signup.md) before starting the lab.

### Program flow

Under is the general program flow described. 

1. Print output
2. Read string from the console
3. Split string to command and data
4. Parse strings to other value types
5. Create queue implementation
6. Insert element
7. Take out element
8. Implement IEnumerable
9. Error if no more elements can be taken out
10. Dependency injection implementation

* The queue implementations should be based on a C# array.

### Prerequisite

To complete this lab, you would need:

* A command line program
  * Windows: Preferably powershell (already installed). 
    * A nice shell for powershell is [Windows Terminal](https://www.microsoft.com/nb-no/p/windows-terminal/9n0dx20hk701) (might be installed with windows) [Alternative link to windows terminal](https://github.com/microsoft/terminal)
  * Linux: A terminal is already installed.
  * Mac: A terminal is already installed. 
* git
  * Check if git is installed by running git in the command line with the command `git`
  * Basic instructions for installing git can be found [here](./Git.md)
* .NET 6.0 installed. Installation instructions can be found on this link [https://dotnet.microsoft.com/download/dotnet/6.0](https://dotnet.microsoft.com/download/dotnet/6.0).
  * Either install the latest **x64** 6.0.x version for your platform under **Build apps - SDK** → **Installers**.
  * Or use the [dotnet-install scripts](https://dotnet.microsoft.com/download/dotnet/scripts)
    * Install dotnet 6 with the command `.\dotnet-install 6.0`
    * For dotnet install script on windows then you might have to run the command `Set-ExecutionPolicy RemoteSigned` to enable script execution in PowerShell
* Visual Studio Code
  * (It is possible to use other code editors, but we cannot provide help for those).
  * Installation can be found here: [https://code.visualstudio.com/](https://code.visualstudio.com/)
    * As part of the windows VSCode installation it is recommended to check the two `Add "Open with code" action to Windows explorer ...` options
* Recommended VSCode extensions
  * Please clone the assignments repository and open the assignments folder in VSCode.
  * VSCode will then prompt to install the recommended extensions.
  * Install the recommended extensions.
    * If this for some reason should not happen, then it is possible to find the list [here](../.vscode/extensions.json).

After the installation it could be a nice thing to log out and in again or just restart the computer.

### Useful links:

* Important for VSCode debugging https://docs.microsoft.com/en-us/dotnet/core/tutorials/debugging-with-visual-studio-code#set-up-for-terminal-input
* Using C# with Visual Studio Code [here](https://code.visualstudio.com/docs/languages/csharp)
* Learn C# [here](https://dotnet.microsoft.com/learn/csharp)
* Learn http status codes with http cats [here](https://http.cat/), (not useful for lab1)
* We could have a long list here but google is better at lists.

## Description

### Opening the lab in VSCode

To start this lab, please navigate to the Lab1 folder and open it in VSCode. When OmniSharp prompts you for which project to choose please select Lab1.sln. This will be the same for all the labs, choose the .sln file.

There might by a description of the [folder structure](./FolderStructure.md) for Lab1.

### The lab

The lab already contains a C# console application in the Lab1/UiS.Dat240.Lab1 folder and can be started by navigating to the folder in the command line and writer `dotnet run`. You should then be greeted by the ubiquitous `Hello World!` code. The console app was generated by running the command: `dotnet new console`.

The code that greets us in the [program.cs](./UiS.Dat240.Lab1/Program.cs) file is the following:

```csharp
// TODO: Implement
Console.WriteLine("Hello World!");
```

And that is it. C# had a much more complicated setup before which can be found in the next part. This file is special since it does not specify a namespace and just have code. Only a single file can be written this way and all other files requires to have classes, interfaces, structs or records wrapped around them. We are also using implicit using statements here, even if `Console` is part of the `System` `namespace`, then we do not need to specify it, since System is imported by defaults in all files. More information about the [C# top level statements can be found here](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements).

#### Old program.cs structure

The `program.cs` in all version before .NET 6 looked like the following. It is nice to know that for older C# code this is what it looked like, but with .NET 6 and newer we do not have to use this format any more.

```csharp
using System;
namespace UiS.Dat240.Lab1
{
    public class Program
    {
        static void Main(string[] args)
        {
           // TODO: Implement
           Console.WriteLine("Hello World!");
        }
    }
}
```

Here is a lot of code to do a simple thing, which is to write the string `Hello World!` to the console window. Currently it is the `Hello World` line that is interesting, which writes the lines to a console window. All you need to know for now is that `static void Main(string[] args)` is a main function which does not return anything (`void`), and expects to get a string array `string[] args` as input. The curly braces `{ }` defines a code body, and the `Main` function is the first thing that is executed in a C# program. The other things just need to be there for now and is mostly about naming things and telling the compiler what we want to use.

### Console input and output

The first things you can try to do with the code to get your feet wet are:
* Manipulate the string `"Hello World"`, 
* Add multiple `Console.WriteLine's`, 
* Try the `Console.Write` function instead of, which does not include the new line at the end of the output.

### Command line program

The first part of the lab should be to read an input from the user and handling what the user writes. The [Console.ReadLine](https://docs.microsoft.com/en-us/dotnet/api/system.console.readline) function can do this operation. After the input is read then it should be [split](https://docs.microsoft.com/en-us/dotnet/api/system.string.split) into command part and data part. The commands which should be implemented can be found in the table below. 

The command reading should read one command after another and only the `exit` command should stop this execution. `CTRL + C` and closing the terminal will also stop the program, and this is expected.

Before we have a real queue implementation it would be nice to test that the command handling is working correctly. This can be accomplished by writing the user input back to the console window. You can try and mimic the following behaviour:

```text
> add Some test value
You wrote: "Some test value"
> rem
You wrote the remove command
> exit
```

We are also going to implement an more advanced and extendable version of the command handling later in the lab with the help of dependency injection.

### Commands:

| Command name | Description                                                         |
| ------------ | ------------------------------------------------------------------- |
| add {value}  | Adds the `{value}` to the queue                                     |
| rem          | Removes the first value from the queue and prints it to the console |
| size         | prints the number of items in the queue                             |
| exit         | Exits the command tool                                              |

### The test project

Let’s learn a little bit about testing our code in an automatic way. We have already prepared a test project which can run some simple test on the queue implementation. If you navigate to the [UiS.Dat240.Lab1/QueueTests.cs](./UiS.Dat240.Lab1.Tests/QueueTests.cs) file you will see three tests. We are using xunit to simplify testing of the code. 

If you have configured VSCode properly then there should be a codelens (The line between the [Fact] and the public void line which cannot be edited) that says something like `0 references | Run Test | Debug test`. The `Run Test` and `Debug Test` is clickable and either starts the test in run mode or in debug mode. In debug mode break points will be hit and it is possible to inspect the code and figure out what the code is doing step by step. If this line is absent, either try to use [Google](https://www.google.com) or ask for help. A restart of the code editor/computer might also do the trick. 

It is also possible to execute the test via the command line. To do this navigate to the folder with the .csproj file and write `dotnet test`. This will run all the tests found the folder.

The nice thing about these tests, (which are [unit test](https://en.wikipedia.org/wiki/Unit_testing) in this case), is that you can take some of the code and verify that it behaves the way you think without having to start the entire application. If we also start to write the test at the same time, we write the implementation then we are forced to write somewhat testable code. Testable code is maybe a little misleading in this case, since all code can be tested in some way, but a lot of code is very easy to write but hard to test since it has a lot of dependencies.

The easiest to write a new test is to copy one of the tests and make some changes to it. One example is to insert to items in the queue instead of one and see that they come out again in the correct order. Another test could be that there is thrown an exception by the code when the code tries to extract an element from an empty queue.

### Building a queue

The second part of the lab is implementing three different versions of a queue. The three queues are [IStringQueue](./UiS.Dat240.Lab1/Queues/IStringQueue.cs), [IObjectQueue](./UiS.Dat240.Lab1/Queues/IObjectQueue.cs) and finally [IGenericQueue<T>](./UiS.Dat240.Lab1/Queues/IGenericQueue.cs). You should first implement the IStringQueue, since then it would be much easier to implement the last two queues as well. Then the object queue should be implemented and lastly, we are going to implement the GenericQueue. 

The FIFO queue (First in First out) implementations should use a [C# Array](https://docs.microsoft.com/en-us/dotnet/api/system.array?view=net-5.0) as the data storage. C# arrays are fixed size which means the code must handle automatic growth of the array to accommodate more elements. [Dynamic Arrays](https://en.wikipedia.org/wiki/Dynamic_array) and [Circular buffers](https://en.wikipedia.org/wiki/Circular_buffer) can be nice starting points for the queue implementation.

The queue should have the following functionality:

| Functionality   | Interface definition        | Description                                                                                                                                                                                                     |
| --------------- | --------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Enqueue(item)   | void Enqueue(string value); | Adds a value to the end of the queue                                                                                                                                                                            |
| Dequeue()       | string Dequeue();           | Returns the first element or throws an exception if the queue is empty                                                                                                                                          |
| Length { get; } | int Length { get; }         | Returns the number of elements in the queue as an integer                                                                                                                                                       |
| Grow()          | Not defined in interfaces   | When called it will create a new array of double the size as the old, copy all elements from the old array to the new array in the same order, then it should assign the new array as the working data storage. |

### IStringQueue

When creating the string queue, first create a class called something like `StringQueue` and then implement the interface `IStringQueue` as shown below. In C# we use the `:` to implement interfaces and derive from other (base/super) classes.

```csharp
public class StringQueue : IStringQueue
{
  public int Length { get; }
  public void Enqueue(string value)
  {
    throw new NotImplementedException();
  }
  public string Dequeue()
  {
    throw new NotImplementedException();
  }
}
```

The main difference between the queues are the types used for storage. The first one can only store strings, but it is easier to reason about since string is a concrete implementation. This queue can also be used for the implementation of the command handling of the program.

After the queue is created then navigate to the [TestSubmissions.cs](./UiS.Dat240.Lab1/TestSubmissions.cs) and modify the code so that it returns a new instance of your string queue implementation as shown below. 

```csharp
public static IStringQueue CreateStringQueue()
{
    // TODO: Implement
    throw new NotImplementedException();
}
```

```csharp
public static IStringQueue CreateStringQueue()
{
    return new StringQueue();
}
```

Also remember to commit and push the changes so you know the QuickFeed score and have saved your work to GitHub. It is a good idea to commit and check the code with QuickFeed after each part of the lab.

### IObjectQueue

Since we at this point have already created the string queue then it is much easier to create the object queue. Create a new class and copy the implementation from the string class and change the `string` types to `object` type instead. 

Now we are basically done, but the big benefit now is that we can store anything which can be [cast](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions) into an object, which in C#, is everything. The bad thing about this implementation is that we do not know what we have stored in the queue, since everything looks like objects. We can also store `strings`, `ints` and anything else in the same queue instance, which can be hard to keep track of.

Do the same for the `ObjectQueue` as the `StringQueue` and add it to the [TestSubmissions.cs](./UiS.Dat240.Lab1/TestSubmissions.cs) file. This will be the same for each implementation.

### Clean up

Now we have two queues which is twice the amount of code to maintain! We also previously mentioned that the `ObjectQueue` can store anything, including strings, so why have two? The next part is creating an encapsulation class or wrapper class which implements the `IStringQueue` interface by using the `ObjectQueue` instead of the concrete implementation.

* Change the existing `StringQueue` or create a new class by creating a new `ObjectQueue` field and assigning it an empty `ObjectQueue`. 
* Change the Enqueue, Dequeue and Size to call the `ObjectQueue` implementations instead
* The Grow function can be deleted since that is handle by the `ObjectQueue`

One thing to note is that Enqueue is easy to implement, it is just calling the `ObjectQueue.Enqueue` function, but the Dequeue is harder. In C# all types are automatically (implicit) cast to a less specific type (for instance a base class or an interface). This means that since everything in C# is an object, then the string is implicitly cast to the object type. The other way around is not true since we do not know what the object should be. More information about casting can be found at the following links:
* https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression
* https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions
* https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions

Use the information in the links to cast the object back to a string before returning it from the dequeue function.

### The Generic Queue IGenericQueue&lt;T&gt;

The bad thing about the string implementation is that we must create a new queue implementation for each type we want, and the bad thing about the object queue is that we have no clue what is in the queue. So, the solution for this is making the C# compiler do all the hard work and create all the type specific versions for us. This is called [generics](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics) and is about using a type variable instead of a concrete type. A type variable is much like a parameter where we do not know the value, but in the case of generics, then we do not know the type. We almost always use the type variable `T` or a name with a `T` as a prefix ex. `TInput` to specify a type parameter. Generics is like creating a template for a `class`, `struct`, `record` or `Method`, where we decide when using the code what type it should be. 

For those that finds this concept cool, then it could be nice to read about a new upcoming dotnet feature which makes [Generic Math](https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/) possible, which takes this concept one step further.

Create a new class with a generic parameter `T` and implement the IGenericQueue&lt;T&gt; interface and copy the ObjectQueue code. Replace all object with T and we are done. Now we should do the same with GenericQueue that we did with ObjectQueue and replace the implementation of both the StringQueue and ObjectQueue to use the new implementation. As you would see, then this is much simpler since we just create a `GenericQueue<string>` for the string queue and `GenericQueue<object>` for the object queue, and then we do not need to cast anything!

### DependencyInjection based command engine

For this part of the lab we are going to implement a more advanced command handler for the command line. We are going to use DependencyInjection og accomplish a more pluggable architecture which should be easy to extend with new commands. It is possible to read more about [Dependency Injection in .NET here](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection) and [Some usage examples](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-usage).

In contrast to the examples there, then we are not going to use a host builder but we are going to create and use the DI container directly. 

#### Creating a DI container and service provider

```csharp
var collection = new ServiceCollection();

// Several
collection.AddSingleton<Interface, Implementation>(...);
// or 
collection.AddScoped<Interface, Implementation>(...);
// or
collection.AddTransient<Interface, Implementation>(...);

var provider = collection.BuildServiceProvider(true);

// getting a service registered in a DI

var someValue = provider.GetService<Interface>();
```

The different `Add...` commands on the ServiceCollection have different lifetimes, which means that for Singleton, you always get the same instance when calling `GetService` on that type, while transient returns a new instance each time. Scoped is a little bit special in that it returns the same service within a scope, but the scope has to be created from the service provider first. 

#### Implementation

To implement the command handler, we are going to create small command classes which implements the interface `ICommandHandler`:

```csharp
public class AddHandler : ICommandHandler
{
  // The name of the command
  public string Name => "CommandName";
  // Since we are going to register the AddHandler in the dependency injection, 
  // then we can request other service from DI in constructor parameters.
  public AddHandler(IStringQueue stringQueue)
  {
    // The request service should also be stored and used later in the class
  }

  // The function to be executed when the user write the command name
  public void Handle(string args)
  {
    // Implement command handler functionality.
  }
}
```

One command handler should be created for each command specified in the table further up, with maybe the exception of the `exit` command. It is also important to register the queue implementation in the dependency injection so that the handlers can access the queue. The tests is also designed in a way that it expects to find all the different queue implementations in the DependencyInjection so remember to register all of them. For the generic `IGenericQueue` it expects to find an `IGenericQueue<string>`

#### Execution engine

For the execution of the commands we are going to use something similar to the following code: 

* Request all commands from the service provider with `provider.GetServices<ICommandHandler>()`
* In a loop
  * Write premable for the command line like `> ` or `cmd>` or something similar
  * Read input from command line with `Console.ReadLine();`
  * Split the command on the first space
  * If the user writes `exit` then exit the loop, this could be implemented as a command, but that is a greater challenge.
  * Check all commands if it contains a command with the Name equal to tje first part of the user input
    * If it is found, run the Handle function on the ICommandHandler with the rest of the user input
    * If it is not found, print an error that the command is not found.

#### Notes

DI is going to be used extensively in the next two labs and the project so it is a good idea to figure out how it works properly.

### IEnumerable

Since we now have some nice data structures, then it would be nice if we could look through them without having to dequeue and re enqueue all the different elements of the queue. It is possible to do that, but it would require a lot of processing. The way we are going to do this is by using the standard C# way of looking through data structures, which is the [foreach](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement) way. As you also can read from the link is that the foreach statement work on a `type` that implements the [IEnumerable](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable?view=net-5.0) or the generic version [IEnumerable<T>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1?view=net-5.0) interfaces. A `type` in this case is any `type` that can implement an interface which are `class`, `struct` or `record` constructs.

The `IEnumerable<T>` should be implemented for the `IGenericQueue<T>` for the tests to pass. There are two ways of creating the enumerable code, where one of them is returning a [IEnumerator<T>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerator-1?view=net-5.0) which navigates through each element one by one, and there is the [yield return](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield). Follow the examples on the links to implement the IEnumerable so the code can be used in a foreach statement. The yield way is probably easier to implement, but yield is just making the compiler implement an IEnumerator for us which is nice.
